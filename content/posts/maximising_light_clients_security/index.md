+++
title = "Maximising light clients security"
date = 2022-05-19T17:45:41+02:00
author = "donnoh.eth"
authorTwitter = "donnoh_eth" #do not include @
cover = "cover.png"
tags = ["fraud-proofs", "data-availability-sampling", "erasure-codes"]
keywords = ["", ""]
description = "An introduction to fraud proofs and data availability sampling."
showFullContent = false
readingTime = true
hideComments = false
draft = false
path = "https://scalability.guide/posts/maximising_light_clients_security/"
+++

This post is a summary of the [Fraud and Data Availability Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities](https://arxiv.org/abs/1809.09044) paper, which is a good introduction to fraud proofs and data availability sampling.

I already discussed what's a node and the difference between light and full nodes in [Decentralization & scalability](https://scalability.guide/posts/decentralization_and_scalability/#blockchain-decentralization-what-is-a-node), so check it out!

---

Since light clients only check [block headers](https://medium.com/coinmonks/ethereum-under-the-hood-part-7-blocks-c8a5f57cc356https://ethereum.github.io/yellowpaper/paper.pdf), they assume that the longest chain contains only valid transactions. In the case of a 51% attack, [where full clients would still reject invalid transactions](https://dankradfeist.de/ethereum/2021/05/20/what-everyone-gets-wrong-about-51percent-attacks.html) a light client would not.

We can eliminate the honest majority assumption for light clients using fraud proofs generated by fully validating nodes (full clients). In this way we bring the assumption down to just one honest fully validating node.

There are two important components that needs to be discussed:

- **fraud proofs**: to prove that a block contains invalid transactions.
- **data availability sampling**: for data availability assurance, needed to generate fraud proofs.

**Goal**: Assuming that it takes `O(N)` time for a full node to validate a block, light clients should discard an invalid block in less than `O(N)` time and space, where `N` is the number of transactions in a block. Note that this is necessary because light clients aren’t fast enough to keep up with the blockchain (otherwise they’d be full nodes). This requires updating the network at the protocol level.

## Fraud proofs
We define a transition as a function `transition(S,t)`, where `S` is the state and `t` a transaction, which outputs a new state `S'` or gives an error.
The state tree is represented with a Patricia tree, but for simplicity assume it's a [sparse Merkle tree](https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837).

We define a new kind of transition function as `rootTransition(stateRoot,t,w)` which outputs a new state root `stateRoot'` or gives an error, where `w` is a sparse Merkle tree proof (a witness) of the parts of the state that the transaction `t` touches.

Note that these Merkle proofs are a subtree of the same state tree with a common root, so we can update the state root without having the whole state tree!

{{< image src="diagram.png" alt="How to recompute the root using a witness" position="center" style="border-radius: 8px;" >}}


Given a list of transactions from a block, we can compute the intermediate state roots, where the last one is the state root of the new block.

We also add a new field inside the block header, the `dataRoot`, which represents transactions arranged into fixed-size chunks of data called "shares", needed for data availability proofs. These shares contains intermediate state roots called "traces" as well as transactions.

A **fraud proof** consists of the relevant shares in the block that contain a bad state transition, Merkle proofs for those shares and the state witness for the transactions contained in those shares.

The function to verify a fraud proof takes as input the fraud proofs and checks if applying the transactions in a period of the block’s data on the intermediate pre-state root results in the intermediate post-state root specified in the block of data. If it does not, then the fraud proof is valid and the block that the fraud proof is for should be permanently rejected by the client.

## Resources
- [Fraud and Data Availability Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities](https://arxiv.org/abs/1809.09044)
- [Ethereum under the hood- Part 7( Blocks )](https://medium.com/coinmonks/ethereum-under-the-hood-part-7-blocks-c8a5f57cc356)
- [What everyone gets wrong about 51% attacks](https://dankradfeist.de/ethereum/2021/05/20/what-everyone-gets-wrong-about-51percent-attacks.html)
- [What’s a Sparse Merkle Tree?](https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837)

